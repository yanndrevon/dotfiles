exports.id=407,exports.ids=[407],exports.modules={6702:(e,t,o)=>{o.d(t,{ComposerWebviewProvider:()=>ComposerWebviewProvider});var i=o(1398),n=o(2941),s=o(67),a=o(2954),r=o(290),c=o(998),m=o(8053),h=o(2549),d=o(2014),l=o(8743),u=o(4176),g=o(9443),f=o(8286);let p="1.0.0",C={hunks:[],commits:[],baseCommit:null,detailsSectionExpanded:{commitMessage:!0,aiExplanation:!0,filesChanged:!0},generatingCommits:!1,generatingCommitMessage:null,committing:!1,safetyError:null,loadingError:null,aiOperationError:null,hasUsedAutoCompose:!1,hasChanges:!0,workingDirectoryHasChanged:!1,indexHasChanged:!1,mode:"preview",recompose:null,aiEnabled:{org:!1,config:!1},ai:{model:void 0},onboardingDismissed:!1},x={sessionStart:"",sessionDuration:void 0,diff:{files:0,hunks:0,lines:0,staged:!1,unstaged:!1,commits:!1,unstagedIncluded:!1},commits:{initialCount:0,autoComposedCount:void 0,composedCount:void 0,finalCount:void 0},ai:{enabled:{org:!1,config:!1},model:void 0},onboarding:{dismissed:!1,stepReached:void 0},operations:{generateCommits:{count:0,cancelledCount:0,errorCount:0,feedback:{upvoteCount:0,downvoteCount:0}},generateCommitMessage:{count:0,cancelledCount:0,errorCount:0},finishAndCommit:{errorCount:0},undo:{count:0},redo:{count:0},reset:{count:0}},source:void 0,mode:"preview",errors:{safety:{count:0},operation:{count:0}},warnings:{workingDirectoryChanged:!1,indexChanged:!1}},w="composer",_=new f.Q2(w,"generateCommits"),y=new f.Q2(w,"generateCommitMessage"),b=new f.Q2(w,"finishAndCommit"),v=new f.Q2(w,"close"),k=new f.Q2(w,"reload"),S=new f.Q2(w,"cancelGenerateCommits"),E=new f.Q2(w,"cancelGenerateCommitMessage");new f.Q2(w,"cancelFinishAndCommit");let I=new f.Q2(w,"clearAIOperationError"),R=new f.Q2(w,"selectAIModel"),A=new f.Q2(w,"aiFeedbackHelpful"),M=new f.Q2(w,"aiFeedbackUnhelpful"),T=new f.Q2(w,"openOnboarding"),D=new f.Q2(w,"dismissOnboarding"),F=new f.Q2(w,"advanceOnboarding"),$=new f.Q2("composer","chooseRepository"),H=new f.Q2(w,"onAddHunksToCommit"),O=new f.Q2(w,"onUndo"),N=new f.Q2(w,"onRedo"),P=new f.Q2(w,"onReset"),z=new f.C1(w,"didStartGenerating"),B=new f.C1(w,"didStartGeneratingCommitMessage"),G=new f.C1(w,"didGenerateCommits"),Q=new f.C1(w,"didGenerateCommitMessage"),U=new f.C1(w,"didStartCommitting"),W=new f.C1(w,"didFinishCommitting"),V=new f.C1(w,"didSafetyError"),j=new f.C1(w,"didReloadComposer"),q=new f.C1(w,"didLoadingError"),L=new f.C1(w,"didWorkingDirectoryChange"),Y=new f.C1(w,"didIndexChange"),Z=new f.C1(w,"didCancelGenerateCommits"),J=new f.C1(w,"didCancelGenerateCommitMessage"),K=new f.C1(w,"didErrorAIOperation"),X=new f.C1(w,"didClearAIOperationError"),ee=new f.C1(w,"didChangeAiEnabled"),et=new f.C1(w,"didChangeAiModel");var eo=o(7163);function ei(e,t){return t.filter(t=>e.hunkIndices.includes(t.index))}function en(e){if(0===e.length)return{patch:"",filePatches:new Map};let t=new Map;for(let o of e){let e=o.diffHeader||`diff --git a/${o.fileName} b/${o.fileName}`,i=t.get(e);if(null==i&&(i=[],t.set(e,i)),o.isRename)i.push("");else{let e=`${o.hunkHeader}
${o.content}`;i.push(e)}}let o="";for(let[e,i]of t.entries()){o+=`${e.trim()}
`;let t=i.filter(e=>""!==e.trim());t.length>0&&(o+=`${t.join(`
`)}
`)}return{patch:o,filePatches:t}}function es(e,t){return Math.max(0,Math.min(e.start+e.count,t.start+t.count)-Math.max(e.start,t.start))}function ea(e,t){let o=[],i=0,n=[];if(e){let t=(0,eo.Tc)(e);({hunks:n,count:i}=er(t,"staged",i)),o.push(...n)}if(t){let e=(0,eo.Tc)(t);({hunks:n,count:i}=er(e,"unstaged",i)),o.push(...n)}return o}function er(e,t,o,i,n){let s=[],a=o;for(let o of e.files)if(o.hunks.length)for(let e of o.hunks){let r=++a,{additions:c,deletions:m}=function(e){let t=e.split(`
`),o=0,i=0;for(let e of t)e.startsWith("+")&&!e.startsWith("+++")?o++:e.startsWith("-")&&!e.startsWith("---")&&i++;return{additions:o,deletions:i}}(e.content),h={index:r,fileName:o.path,originalFileName:o.originalPath,diffHeader:o.header,hunkHeader:e.header,content:e.content,additions:c,deletions:m,source:t,assigned:!1,isRename:!1,author:i,coAuthors:n};s.push(h)}else{let e,r,c=++a;if(o.metadata.binary)e="binary",r="Binary file";else if(o.metadata.modeChanged)e="mode change",r=`Mode change from ${o.metadata.modeChanged.oldMode||"?"} to ${o.metadata.modeChanged.newMode||"?"}`;else if(o.metadata.renamedOrCopied){e="rename";let t=o.metadata.renamedOrCopied?.similarity||100;r=`Rename from ${o.originalPath}
Rename to ${o.path}
Similarity index ${t}%`}else e="no-content-change",r=o.header.split(`
`).slice(1).join(`
`);let m={index:c,fileName:o.path,originalFileName:o.originalPath,diffHeader:o.header,hunkHeader:e,content:r,additions:0,deletions:0,source:t,assigned:!1,isRename:!1!==o.metadata.renamedOrCopied,author:i,coAuthors:n};s.push(m)}return{hunks:s,count:a}}async function ec(e,t){if(t){let o=await eu(e,t.baseSha,t.headSha);return{staged:void 0,unstaged:void 0,commits:o,unified:o}}let[o,i,n]=await Promise.allSettled([e.git.diff.getDiff?.(a.id),e.git.diff.getDiff?.(a.SU),e.git.diff.getDiff?.(a.SU,"HEAD",{notation:"..."})]);return{staged:(0,u.Ro)(o),unstaged:(0,u.Ro)(i),unified:(0,u.Ro)(n),commits:void 0}}async function em(e,t,o,i,s){return{repoPath:e.path,headSha:i??null,baseSha:o??null,branchName:s,hashes:{staged:t.staged?.contents?await (0,n.sc)(t.staged.contents):null,unstaged:t.unstaged?.contents?await (0,n.sc)(t.unstaged.contents):null,unified:t.unified?.contents?await (0,n.sc)(t.unified.contents):null,commits:t.commits?.contents?await (0,n.sc)(t.commits.contents):null}}}async function eh(e,t,o,i){let s=[];try{if(e.path!==t.repoPath&&s.push(`Repository path changed from "${t.repoPath}" to "${e.path}"`),t.branchName){let o=await e.git.branches.getBranch(t.branchName);o?.sha!==t.headSha&&s.push(`HEAD commit changed from "${t.headSha}" to "${o?.sha}"`)}else{let o=await e.git.commits.getCommit("HEAD"),i=o?.sha??null;i!==t.baseSha&&s.push(`HEAD commit changed from "${t.baseSha}" to "${i}"`)}if(o?.length)if(t.hashes.commits){if(null===t.baseSha)return{isValid:!1,errors:["Base commit is null"]};if(null===t.headSha)return{isValid:!1,errors:["Head commit is null"]};let o=await eu(e,t.baseSha,t.headSha);if(!o?.contents)return{isValid:!1,errors:["Failed to calculate combined diff"]};await (0,n.sc)(o.contents)!==t.hashes.commits&&s.push("Branch changes have been modified since composer opened")}else{let{staged:a,unstaged:r}=i??await ec(e)??{staged:void 0,unstaged:void 0,unified:void 0},c={staged:a?.contents?await (0,n.sc)(a.contents):null,unstaged:r?.contents?await (0,n.sc)(r.contents):null};o.some(e=>"staged"===e.source)&&c.staged!==t.hashes.staged&&s.push("Staged changes have been modified since composer opened"),o.some(e=>"unstaged"===e.source)&&c.unstaged!==t.hashes.unstaged&&s.push("Unstaged changes have been modified since composer opened")}return{isValid:!s.length,errors:s}}catch(e){return s.push(`Failed to validate repository state: ${e instanceof Error?e.message:"Unknown error"}`),{isValid:!1,errors:s}}}async function ed(e,t,o,i){try{let e,n=await t.git.branches.getBranch(o);if(!n||(i&&(e=await t.git.branches.getBranch(i)),!e))return;let s=await t.git.refs.getMergeBase(n.ref,e.ref);if(!s)return;let a=await t.git.commits.getCommit(s);if(!a)return;let r=await t.git.commits.getLog(`${e.ref}..${n.ref}`,{limit:0});if(!r?.commits?.size)return;let c=Array.from(r.commits.values()).reverse(),m=c[c.length-1];return{commits:c,baseCommit:{sha:a.sha,message:a.message??""},headCommitSha:m?.sha??n.sha}}catch{return}}async function el(e,t){try{let o=await e.git.config.getCurrentUser(),i=[],n=[],s=0;for(let a of t){let t=e.git.diff;if(!t?.getDiff)continue;let r=await t.getDiff(a.sha,`${a.sha}~1`);if(!r?.contents)continue;let c=(0,eo.Tc)(r.contents),m=[],h={...a.author,name:"You"===a.author.name?o?.name??a.author.name:a.author.name},{hunks:d,count:l}=er(c,"commits",s,h,function(e){let t,o=[];if(!e.message)return o;let i=/^Co-authored-by:\s*(.+?)(?:\s*<(.+?)>)?\s*$/gm;for(;null!==(t=i.exec(e.message));){let[,i,n]=t;i&&o.push({name:i.trim(),email:n?.trim(),date:e.date})}return o}(a));n.push(...d),s=l,m.push(...d.map(e=>e.index));let u={id:a.sha,message:{content:a.message||"",isGenerated:!1},sha:a.sha,hunkIndices:m};i.push(u)}return{commits:i,hunks:n}}catch{return}}async function eu(e,t,o){try{let i=e.git.diff;if(!i?.getDiff)return;let n=await i.getDiff(o,t);if(!n?.contents)return;return n}catch{return}}let ComposerWebviewProvider=class ComposerWebviewProvider{constructor(e,t){this.container=e,this.host=t,this._disposable=i.Disposable.from(d.H.onDidChangeAny(this.onAnyConfigurationChanged,this),(0,l.wt)(this.onContextChanged,this),this.container.ai.onDidChangeModel(this.onAIModelChanged,this)),this._context={...x},this._safetyState={repoPath:"",headSha:null,baseSha:null,hashes:{staged:null,unstaged:null,unified:null}}}_disposable;_args;_cache=new g.od({accessTTL:3e5});_generateCommitsCancellation;_generateCommitMessageCancellation;_repositorySubscription;_currentRepository;_hunks=[];_safetyState;_recompose=null;_context;_ignoreIndexChange=!1;dispose(){this._cache.clear(),this.resetContext(),this._generateCommitsCancellation?.dispose(),this._generateCommitMessageCancellation?.dispose(),this._repositorySubscription?.dispose(),this._disposable.dispose()}onMessageReceived(e){switch(!0){case _.is(e):this.onGenerateCommits(e.params);break;case y.is(e):this.onGenerateCommitMessage(e.params);break;case b.is(e):this.onFinishAndCommit(e.params);break;case v.is(e):this.close();break;case k.is(e):this.onReloadComposer(e.params);break;case R.is(e):this.onSelectAIModel();break;case A.is(e):this.onAIFeedbackHelpful(e.params);break;case M.is(e):this.onAIFeedbackUnhelpful(e.params);break;case S.is(e):this.onCancelGenerateCommits();break;case E.is(e):this.onCancelGenerateCommitMessage();break;case I.is(e):this.onClearAIOperationError();break;case T.is(e):this.onOpenOnboarding();break;case F.is(e):this.onAdvanceOnboarding(e.params);break;case D.is(e):this.onDismissOnboarding();break;case H.is(e):this.onAddHunksToCommit(e.params);break;case O.is(e):this.onUndo();break;case N.is(e):this.onRedo();break;case P.is(e):this.onReset();break;case $.is(e):this.onChooseRepository()}}getTelemetryContext(){return{...this.host.getTelemetryContext(),"context.session.start":this._context.sessionStart,"context.session.duration":this._context.sessionDuration,"context.source":this._context.source,"context.mode":this._context.mode,"context.diff.files.count":this._context.diff.files,"context.diff.hunks.count":this._context.diff.hunks,"context.diff.lines.count":this._context.diff.lines,"context.diff.staged.exists":this._context.diff.staged,"context.diff.unstaged.exists":this._context.diff.unstaged,"context.diff.unstaged.included":this._context.diff.unstagedIncluded,"context.commits.initialCount":this._context.commits.initialCount,"context.commits.autoComposedCount":this._context.commits.autoComposedCount,"context.commits.composedCount":this._context.commits.composedCount,"context.commits.finalCount":this._context.commits.finalCount,"context.ai.enabled.config":this._context.ai.enabled.config,"context.ai.enabled.org":this._context.ai.enabled.org,"context.ai.model.id":this._context.ai.model?.id,"context.ai.model.name":this._context.ai.model?.name,"context.ai.model.provider.id":this._context.ai.model?.provider.id,"context.ai.model.temperature":this._context.ai.model?.temperature??void 0,"context.ai.model.maxTokens.input":this._context.ai.model?.maxTokens.input,"context.ai.model.maxTokens.output":this._context.ai.model?.maxTokens.output,"context.ai.model.default":this._context.ai.model?.default,"context.ai.model.hidden":this._context.ai.model?.hidden,"context.onboarding.stepReached":this._context.onboarding.stepReached,"context.onboarding.dismissed":this._context.onboarding.dismissed,"context.operations.generateCommits.count":this._context.operations.generateCommits.count,"context.operations.generateCommits.cancelled.count":this._context.operations.generateCommits.cancelledCount,"context.operations.generateCommits.error.count":this._context.operations.generateCommits.errorCount,"context.operations.generateCommits.feedback.upvote.count":this._context.operations.generateCommits.feedback.upvoteCount,"context.operations.generateCommits.feedback.downvote.count":this._context.operations.generateCommits.feedback.downvoteCount,"context.operations.generateCommitMessage.count":this._context.operations.generateCommitMessage.count,"context.operations.generateCommitMessage.cancelled.count":this._context.operations.generateCommitMessage.cancelledCount,"context.operations.generateCommitMessage.error.count":this._context.operations.generateCommitMessage.errorCount,"context.operations.finishAndCommit.error.count":this._context.operations.finishAndCommit.errorCount,"context.operations.undo.count":this._context.operations.undo.count,"context.operations.redo.count":this._context.operations.redo.count,"context.operations.reset.count":this._context.operations.reset.count,"context.warnings.workingDirectoryChanged":this._context.warnings.workingDirectoryChanged,"context.warnings.indexChanged":this._context.warnings.indexChanged,"context.errors.safety.count":this._context.errors.safety.count,"context.errors.operation.count":this._context.errors.operation.count}}includeBootstrap(e){return this._cache.getOrCreate("bootstrap",()=>this.getBootstrapState())}async getBootstrapState(){let e;this.container.git.isDiscoveringRepositories&&await this.container.git.isDiscoveringRepositories;let t=this._args;return null==(e=t?.repoPath!=null?this.container.git.getRepository(t.repoPath):this.container.git.getBestRepositoryOrFirst())?{...this.initialState,loadingError:"No repository found. Please open a Git repository to use the Commit Composer."}:t?.range?this.initializeStateAndContextFromExplicitRange(e,t.branchName,t.range,t.mode,t.source,t.commitShas):t?.branchName?this.initializeStateAndContextFromBranch(e,t.branchName,t.mode,t.source,t.commitShas):this.initializeStateAndContextFromWorkingDirectory(e,t?.includedUnstagedChanges,t?.mode,t?.source)}get initialState(){return{...this.host.baseWebviewState,...C}}async initializeStateAndContext(e,t,o,i,n,s,a,r="preview",c,m,h){this._currentRepository=e,this._hunks=t;let d=await em(e,i,n?.sha,s,a);if(this._safetyState=d,(a||n&&s)&&(this._recompose={enabled:!0,branchName:a,locked:!0,commitShas:m}),m&&m.length>0){let e=new Set(m);for(let t of o)t.sha&&!e.has(t.sha)&&(t.locked=!0)}let l=this.getAiEnabled(),u=await this.container.ai.getModel({silent:!0},{source:"composer",correlationId:this.host.instanceId}),g=this.isOnboardingDismissed(),f=this.getOnboardingStepReached();return this._context.diff.files=new Set(t.map(e=>e.fileName)).size,this._context.diff.hunks=t.length,this._context.diff.lines=t.reduce((e,t)=>e+t.content.split(`
`).length-1,0),this._context.commits.initialCount=0,this._context.ai.enabled.org=l.org,this._context.ai.enabled.config=l.config,this._context.ai.model=u,this._context.onboarding.dismissed=g,this._context.onboarding.stepReached=f,this._context.source=c,this._context.mode=r,this._context.warnings.workingDirectoryChanged=!1,this._context.warnings.indexChanged=!1,this._context.sessionStart=new Date().toISOString(),this.sendTelemetryEvent(h?"composer/reloaded":"composer/loaded"),{...this.initialState,hunks:t,baseCommit:n??null,commits:o,aiEnabled:l,ai:{model:u},hasChanges:o.length>0,mode:r,onboardingDismissed:g,workingDirectoryHasChanged:!1,indexHasChanged:!1,repositoryState:this.getRepositoryState(),recompose:this._recompose??null}}async initializeStateAndContextFromWorkingDirectory(e,t,o="preview",i,n){this._repositorySubscription?.dispose();let s=(await e.git.status?.getUntrackedFiles())?.map(e=>e.path);if(s?.length)try{await e.git.staging?.stageFiles(s,{intentToAdd:!0}),this._ignoreIndexChange=!0}catch{}let[a,r,c]=await Promise.allSettled([ec(e),e.git.commits.getCommit("HEAD"),e.git.branches.getBranch()]);s?.length&&await e.git.staging?.unstageFiles(s).catch();let m=(0,u.Ro)(a);this._context.diff.unstagedIncluded=!1,t&&(this._context.diff.unstagedIncluded=!0);let h=this._context.diff.unstagedIncluded?m?.unified:m?.staged,d=this._context.diff.unstagedIncluded?void 0:m?.unstaged;!m?.staged?.contents&&m?.unstaged?.contents&&(this._context.diff.unstagedIncluded=!0);let l=!!(h?.contents||d?.contents),g=ea(h?.contents,d?.contents),f=(0,u.Ro)(r),p=(0,u.Ro)(c),C=!!h?.contents,x=!!d?.contents,w={id:"draft-commit-1",message:{content:"",isGenerated:!1},aiExplanation:"",hunkIndices:C&&x?g.filter(e=>"staged"===e.source).map(e=>e.index):g.map(e=>e.index)};return this._context.diff.staged=C,this._context.diff.unstaged=x,this._context.diff.commits=!1,this.subscribeToRepository(e),this.initializeStateAndContext(e,g,l?[w]:[],m,f?{sha:f.sha,message:f.message??"",repoName:e.name,branchName:p?.name??"main"}:void 0,void 0,void 0,o,i,void 0,n)}async initializeStateAndContextFromBranch(e,t,o="preview",i,n,s){let a,c=await e.git.branches.getBranch(t);if(!c)return{...this.initialState,loadingError:`Branch '${t}' not found.`};let m=t,h=c,d=new Set,l=0;for(;l<10&&(l++,!d.has(m));){d.add(m);let c=await (0,r.DY)(this.container,h);if(!c.paused&&c.value){a=c.value;let r=await ed(this.container,e,t,a);if(r&&r.commits.length>0){let{commits:a,baseCommit:c,headCommitSha:h}=r,d=await el(e,a);if(!d)return{...this.initialState,loadingError:`Failed to process commits for branch '${t}'.`};let{commits:l,hunks:u}=d;if(n){let e=[...new Set(n)].filter(e=>!l.find(t=>t.sha===e));if(e.length>0)return{...this.initialState,loadingError:`The following commit shas were not found in the commits for branch '${t}': ${e.join(", ")}`}}let g=await ec(e,{baseSha:c.sha,headSha:h});return this.initializeStateAndContext(e,u,l,g,{sha:c.sha,message:c.message,repoName:e.name,branchName:t},h,m,o,i,n,s)}let d=await e.git.branches.getBranch(a);if(!d||d.name===m)break;m=d.name,h=d}else break}if(n?.length){let a=c.sha,r=(await e.git.commits.getCommit(n[0]))?.parents[0];if(a&&r)return this.initializeStateAndContextFromExplicitRange(e,t,{base:r,head:a},o,i,n,s)}return{...this.initialState,loadingError:`Could not identify unique commits for branch '${t}'`}}async initializeStateAndContextFromExplicitRange(e,t,o,i="preview",n,s,a){let{base:r,head:c}=o,m=await e.git.commits.getCommit(r);if(!m)return{...this.initialState,loadingError:`Base commit '${r}' not found.`};if(!await e.git.commits.getCommit(c))return{...this.initialState,loadingError:`Head commit '${c}' not found.`};let h=await e.git.commits.getLog(`${r}..${c}`,{limit:0});if(!h?.commits?.size)return{...this.initialState,loadingError:"No commits found between base commit and head commit."};let d=Array.from(h.commits.values()).reverse(),l=await el(e,d);if(!l)return{...this.initialState,loadingError:t?`Failed to process commits for branch '${t}'.`:"Failed to process commits in range."};let{commits:u,hunks:g}=l;if(s&&s.length>0){let e=[...new Set(s)].filter(e=>!u.find(t=>t.sha===e));if(e.length>0)return{...this.initialState,loadingError:t?`The following commit shas were not found in the commits for branch '${t}': ${e.join(", ")}`:`The following commit shas were not found in the commits: ${e.join(", ")}`}}let f=await ec(e,{baseSha:r,headSha:c}),p={sha:r,message:m.message??"",repoName:e.name,branchName:t},C=await this.initializeStateAndContext(e,g,u,f,p,c,t,i,n,s,a);return this._recompose&&(this._recompose.range=o),C}getRepositoryState(){if(null==this._currentRepository)return;let{id:e,name:t,path:o,uri:i,virtual:n}=this._currentRepository;return{current:{id:e,name:t,path:o,uri:i.toString(),virtual:n},hasMultipleRepositories:this.container.git.openRepositoryCount>1}}async onAddHunksToCommit(e){"unstaged"===e.source&&(this._context.diff.unstagedIncluded=!0,this.sendTelemetryEvent("composer/action/includedUnstagedChanges"),await this.onReloadComposer({repoPath:this._currentRepository.path,mode:this._context.mode}))}onUndo(){this._context.operations.undo.count++,this.sendTelemetryEvent("composer/action/undo")}onRedo(){this._context.operations.redo.count++}onReset(){this._context.operations.reset.count++,this.sendTelemetryEvent("composer/action/reset")}async onChooseRepository(){let{title:e,placeholder:t}=await (0,m.Nt)(this.container.git.openRepositories,"Switch",this._currentRepository?.name),o=await (0,m.oe)(this.container,e,t,this.container.git.openRepositories,{picked:this._currentRepository});null!=o&&await this.onReloadComposer({repoPath:o.path,source:"composer"})}async onReloadComposer(e){try{let t;this._cache.clear();let o=this._currentRepository;if((!o||null!=e.repoPath&&o?.path!==e.repoPath)&&!(o=null==e.repoPath?this.container.git.getBestRepositoryOrFirst():this.container.git.getRepository(e.repoPath))){this._context.errors.safety.count++;let e="Repository is no longer available";this.sendTelemetryEvent("composer/reloaded",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(V,{error:e});return}if((t=this._recompose?.range?await this.initializeStateAndContextFromExplicitRange(o,this._recompose.branchName,this._recompose.range,e.mode,this._context.source,this._recompose.commitShas,!0):this._recompose?.branchName?await this.initializeStateAndContextFromBranch(o,this._recompose.branchName,e.mode,this._context.source,this._recompose.commitShas,!0):await this.initializeStateAndContextFromWorkingDirectory(o,this._context.diff.unstagedIncluded,e.mode,this._context.source,!0)).loadingError)return void await this.host.notify(q,{error:t.loadingError});await this.host.notify(j,{hunks:t.hunks,commits:t.commits,baseCommit:t.baseCommit,loadingError:t.loadingError,hasChanges:t.hasChanges,repositoryState:t.repositoryState})}catch(e){this.sendTelemetryEvent("composer/reloaded",{"failure.reason":"error","failure.error.message":e instanceof Error?e.message:"unknown error"}),await this.host.notify(q,{error:e instanceof Error?e.message:"Failed to reload composer"})}}async onCancelGenerateCommits(){this._generateCommitsCancellation&&(this._generateCommitsCancellation.cancel(),await this.host.notify(Z,void 0))}async onCancelGenerateCommitMessage(){this._generateCommitMessageCancellation&&(this._generateCommitMessageCancellation.cancel(),await this.host.notify(J,void 0))}async onClearAIOperationError(){await this.host.notify(X,void 0)}onOpenOnboarding(){this.advanceOnboardingStep(1)}onAdvanceOnboarding(e){this.advanceOnboardingStep(e.stepNumber)}advanceOnboardingStep(e){if(this.isOnboardingDismissed())return;let t=Math.max(this.container.storage.get("composer:onboarding:stepReached")??1,e);this._context.onboarding.stepReached=t,this.container.storage.store("composer:onboarding:stepReached",t).catch()}onDismissOnboarding(){this.isOnboardingDismissed()||(this._context.onboarding.dismissed=!0,this.container.storage.store("composer:onboarding:dismissed",p).catch())}isOnboardingDismissed(){return this.container.storage.get("composer:onboarding:dismissed")===p}getOnboardingStepReached(){return this.container.storage.get("composer:onboarding:stepReached")}resetContext(){this._context={...x}}onShowing(e,t,...o){return o?.[0]&&(this._cache.clear(),this.resetContext(),this._args=o[0],this.updateTitle(o[0].mode)),[!0,void 0]}updateTitle(e){"experimental"===(e??this._args?.mode??"preview")?this.host.title="Commit Composer (Experimental)":this.host.title="Commit Composer (Preview)"}async close(){this._context.sessionDuration=Date.now()-new Date(this._context.sessionStart).getTime(),await i.commands.executeCommand("workbench.action.closeActiveEditor")}async updateAiModel(){try{let e=await this.container.ai.getModel({silent:!0},{source:"composer",correlationId:this.host.instanceId});this._context.ai.model=e,this.sendTelemetryEvent("composer/action/changeAiModel"),await this.host.notify(et,{model:e})}catch{}}async onSelectAIModel(){await i.commands.executeCommand("gitlens.ai.switchProvider",{source:"composer",correlationId:this.host.instanceId,detail:"model-picker"})}async onAIFeedbackHelpful(e){this._context.operations.generateCommits.feedback.upvoteCount++,await this.sendComposerAIFeedback("helpful",e.sessionId)}async onAIFeedbackUnhelpful(e){this._context.operations.generateCommits.feedback.downvoteCount++,await this.sendComposerAIFeedback("unhelpful",e.sessionId)}async sendComposerAIFeedback(e,t){try{let o,i=await this.container.ai.getModel({silent:!0},{source:"composer",correlationId:this.host.instanceId});if(!i)return;let n={id:t||"composer-session",type:"generate-commits",feature:"composer",model:{id:i.id,name:i.name,maxTokens:i.maxTokens,provider:{id:i.provider.id,name:i.provider.name},default:i.default,hidden:i.hidden,temperature:i.temperature},usage:void 0};if("unhelpful"===e&&(o=await (0,c.E)(),void 0===o))return;(0,c._)(this.container,{source:"composer",correlationId:this.host.instanceId},n,e,o)}catch{}}subscribeToRepository(e){this._repositorySubscription?.dispose(),this._repositorySubscription=i.Disposable.from(e.watchFileSystem(1e3),e.onDidChangeFileSystem(this.onRepositoryFileSystemChanged,this),e.onDidChange(this.onRepositoryChanged,this))}async onRepositoryChanged(e){if(e.repository.id!==this._currentRepository?.id)return;let t=this._ignoreIndexChange;this._ignoreIndexChange=!1,!e.changed(s.Z_.Index,s.Ti.Any)||t&&e.changed(s.Z_.Index,s.Ti.Exclusive)||(this._context.warnings.indexChanged=!0,await this.host.notify(Y,void 0))}async onRepositoryFileSystemChanged(e){e.repository.id===this._currentRepository?.id&&(this._context.warnings.workingDirectoryChanged=!0,await this.host.notify(L,void 0))}async onGenerateCommits(e){let t={"customInstructions.used":!1,"customInstructions.length":0,"customInstructions.hash":"","customInstructions.setting.used":!1,"customInstructions.setting.length":0};try{let o=d.H.get("ai.generateCommits.customInstructions");o&&(t["customInstructions.setting.used"]=!0,t["customInstructions.setting.length"]=o.length),this._context.operations.generateCommits.count++,e.customInstructions&&(t["customInstructions.used"]=!0,t["customInstructions.length"]=e.customInstructions.length,t["customInstructions.hash"]=(0,n.Fx)(e.customInstructions)),this._generateCommitsCancellation=new i.CancellationTokenSource,await this.host.notify(z,void 0);let s=[];if(this._recompose?.enabled&&this._safetyState?.hashes.commits){let t=e.commitsToReplace?.baseShaForNewDiff??this._safetyState.baseSha,o=this._safetyState.headSha;if(e.commitsToReplace?.commits?.length&&(o=e.commitsToReplace.commits[e.commitsToReplace.commits.length-1].sha??this._safetyState.headSha),e.commitsToReplace?.commits?.length&&e.commitsToReplace.commits.every(e=>!e.sha))for(let t of new Set(e.commitsToReplace.commits.flatMap(e=>e.hunkIndices)))s.push({...this._hunks.find(e=>e.index===t),assigned:!0});else{let i=await eu(this._currentRepository,t,o);for(let e of ea(i.contents)){let{author:t,coAuthors:o}=function(e,t){let o,i=e.filter(e=>null!=e.author&&e.fileName===t.fileName&&(!t.isRename||e.isRename===t.isRename)),n=new Map,s=new Map,a=0;for(let e of i){s.set(e.author.name,e.author),e.coAuthors?.forEach(e=>s.set(e.name,e));let i=function(e,t){let o=e.hunkHeader.match(/@@ -(\d+),(\d+)/),i=e.hunkHeader.match(/@@ -\d+,\d+ \+(\d+),(\d+)/),n=t.hunkHeader.match(/@@ -(\d+),(\d+)/),s=t.hunkHeader.match(/@@ -\d+,\d+ \+(\d+),(\d+)/);return null==o||null==i||null==n||null==s?0:es({start:parseInt(o[1],10),count:parseInt(o[2],10)},{start:parseInt(n[1],10),count:parseInt(n[2],10)})+es({start:parseInt(i[1],10),count:parseInt(i[2],10)},{start:parseInt(s[1],10),count:parseInt(s[2],10)})}(e,t);n.has(e.author.name)&&(i+=n.get(e.author.name)),n.set(e.author.name,i),(null==o||i>a)&&(a=i,o=e.author)}return null!=o&&s.delete(o.name),{author:o,coAuthors:[...s.values()]}}(this._hunks,e);e.author=t,e.coAuthors=o.length?o:void 0,s.push({...e,assigned:!0})}if(e.commitsToReplace){let t=new Set(e.commitsToReplace.commits.flatMap(e=>e.hunkIndices));this._hunks=this._hunks.filter(e=>!t.has(e.index));let o=1;this._hunks.forEach(e=>{e.index=o++}),s.forEach(e=>{e.index=o++}),this._hunks.push(...s)}else this._hunks=s}}else for(let t of e.hunkIndices)s.push({...this._hunks.find(e=>e.index===t),assigned:!0});let a=e.commits.map(e=>({id:e.id,message:e.message.content,aiExplanation:e.aiExplanation,hunkIndices:e.hunkIndices})),r=await this.container.ai.actions.generateCommits(s,a,s.map(e=>({index:e.index,hunkHeader:e.hunkHeader})),{source:"composer",correlationId:this.host.instanceId},{cancellation:this._generateCommitsCancellation.token,customInstructions:e.customInstructions});if(this._generateCommitsCancellation?.token.isCancellationRequested){this._context.operations.generateCommits.cancelledCount++,this.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(Z,void 0);return}if(r&&"cancelled"!==r){if(0===r.commits.length){this._context.operations.generateCommits.errorCount++,this._context.errors.operation.count++,this.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"error","failure.error.message":"no commits generated"}),await this.host.notify(K,{operation:"generate commits",error:"No commits generated"});return}let o=r.commits.map((e,t)=>({id:`ai-commit-${t}`,message:{content:e.message,isGenerated:!0},aiExplanation:e.explanation,hunkIndices:e.hunks.map(e=>e.hunk)}));this._context.commits.autoComposedCount=o.length,this.sendTelemetryEvent(e.isRecompose?"composer/action/recompose":"composer/action/compose",t),this._recompose?.enabled&&(this._recompose.locked=!1),await this.host.notify(G,{commits:o,hunks:this._recompose?.enabled?this._hunks:void 0,replacedCommitIds:e.commitsToReplace?.commits.map(e=>e.id)})}else"cancelled"===r?(this._context.operations.generateCommits.cancelledCount++,await this.host.notify(Z,void 0)):(this._context.operations.generateCommits.errorCount++,this._context.errors.operation.count++,this.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"error","failure.error.message":"unknown error"}),await this.host.notify(K,{operation:"generate commits",error:void 0}))}catch(o){this._generateCommitsCancellation?.token.isCancellationRequested?(this._context.operations.generateCommits.cancelledCount++,this.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(Z,void 0)):(this._context.operations.generateCommits.errorCount++,this._context.errors.operation.count++,this.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"error","failure.error.message":o instanceof Error?o.message:"unknown error"}),await this.host.notify(K,{operation:"generate commits",error:o instanceof Error?o.message:void 0}))}finally{this._generateCommitsCancellation?.dispose(),this._generateCommitsCancellation=void 0}}async onGenerateCommitMessage(e){let t={"customInstructions.setting.used":!1,"customInstructions.setting.length":0,overwriteExistingMessage:e.overwriteExistingMessage??!1};try{let o=d.H.get("ai.generateCommitMessage.customInstructions");o&&(t["customInstructions.setting.used"]=!0,t["customInstructions.setting.length"]=o.length),this._context.operations.generateCommitMessage.count++,this._generateCommitMessageCancellation=new i.CancellationTokenSource,await this.host.notify(B,{commitId:e.commitId});let{patch:n}=en(this._hunks.filter(t=>e.commitHunkIndices.includes(t.index)));n||(this._context.operations.generateCommitMessage.errorCount++,this._context.errors.operation.count++,this.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"error","failure.error.message":"Failed to create diff for commit"}),await this.host.notify(K,{operation:"generate commit message",error:"Failed to create diff for commit"}));let s=await this.container.ai.actions.generateCommitMessage(n,{source:"composer",correlationId:this.host.instanceId},{cancellation:this._generateCommitMessageCancellation.token});if(this._generateCommitMessageCancellation?.token.isCancellationRequested){this._context.operations.generateCommitMessage.cancelledCount++,this.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(J,void 0);return}if(s&&"cancelled"!==s){let o=s.result.body?`${s.result.summary}

${s.result.body}`:s.result.summary;this.sendTelemetryEvent("composer/action/generateCommitMessage",t),await this.host.notify(Q,{commitId:e.commitId,message:o})}else"cancelled"===s?(this._context.operations.generateCommitMessage.cancelledCount++,this.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(J,void 0)):(this._context.operations.generateCommitMessage.errorCount++,this._context.errors.operation.count++,this.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"error","failure.error.message":"unknown error"}),await this.host.notify(K,{operation:"generate commit message",error:void 0}))}catch(e){this._generateCommitMessageCancellation?.token.isCancellationRequested?(this._context.operations.generateCommitMessage.cancelledCount++,this.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(J,void 0)):(this._context.operations.generateCommitMessage.errorCount++,this._context.errors.operation.count++,this.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"error","failure.error.message":e instanceof Error?e.message:"unknown error"}),await this.host.notify(K,{operation:"generate commit message",error:e instanceof Error?e.message:void 0}))}finally{this._generateCommitMessageCancellation?.dispose(),this._generateCommitMessageCancellation=void 0}}async onFinishAndCommit(e){try{var t;let o,s,r,c;await this.host.notify(U,void 0);let m=this.container.git.getRepository(this._safetyState.repoPath);if(!m){await this.host.notify(W,void 0),this._context.errors.safety.count++,this._context.errors.operation.count++;let e="Repository is no longer available";this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(V,{error:e});return}let h=e.commits.flatMap(e=>e.hunkIndices),d=[];for(let e of h)d.push({...this._hunks.find(t=>t.index===e),assigned:!0});let l=d.filter(t=>e.commits.some(e=>e.hunkIndices.includes(t.index)));if(this._context.diff.unstagedIncluded){this._repositorySubscription?.dispose();let e=(await m.git.status?.getUntrackedFiles())?.map(e=>e.path);if(e?.length)try{o=await ec(m),await m.git.staging?.stageFiles(e)}catch{}}let u=await eh(m,this._safetyState,l,o);if(!u.isValid){await this.host.notify(W,void 0),this._context.errors.safety.count++,this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e=u.errors.join(`
`);this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(V,{error:e});return}let g=(t=e.commits,t.map(e=>{let{patch:t,filePatches:o}=en(ei(e,d)),{author:i,coAuthors:n}=function(e){let t,o=new Map,i=new Map;for(let t of e)null!=t.author&&(i.set(t.author.name,t.author),t.coAuthors?.forEach(e=>i.set(e.name,e)),o.set(t.author.name,(o.get(t.author.name)??0)+t.additions+t.deletions));let n=0;for(let[e,s]of o.entries())(null==t||s>n)&&(t=i.get(e),n=s);return null!=t&&i.delete(t.name),{author:t,coAuthors:[...i.values()]}}(ei(e,d)),s=e.message.content;return n.length>0&&(s+=`
${n.map(e=>`
Co-authored-by: ${e.name} <${e.email}>`).join()}`),{message:s,explanation:e.aiExplanation,filePatches:o,patch:t,author:i}})),f=this.container.git.getRepositoryService(m.path);if(!f){this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e="No repository service found";throw this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),Error(e)}if(e.baseCommit?.sha==null){let e=await f.patch?.createEmptyInitialCommit();if(null==e){this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e="Could not create base commit";throw this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),Error(e)}}let p=await m.git.patch?.createUnreachableCommitsFromPatches(e.baseCommit?.sha,g);if(!p?.length){this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e="Failed to create commits from patches";throw this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),Error(e)}let C=e.baseCommit?.sha??(await m.git.commits.getCommit("HEAD")?"HEAD":a.BI),x=(await m.git.diff.getDiff?.(p[p.length-1],C,{notation:e.baseCommit?.sha?"...":void 0}))?.contents;if(!x){this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e="Failed to get combined diff";throw this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),Error(e)}if(!function(e,t,o){let{hashes:i}=e;return i.commits?t===i.commits:t===(o?i.unified:i.staged)}(this._safetyState,await (0,n.sc)(x),this._context.diff.unstagedIncluded)){await this.host.notify(W,void 0),this._context.errors.safety.count++,this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e="Output diff does not match input";this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(V,{error:e});return}let w=!1;if(await m.git.status.hasWorkingChanges({throwOnError:!0})){if(r=await f.stash?.getStash(),r?.stashes.size){let e=r.stashes.values().next().value;e&&(s=e)}let e=`Commit composer: ${new Date().toLocaleString()}`;await f.stash?.saveStash(e,void 0,{includeUntracked:!0}),r=await f.stash?.getStash(),r?.stashes.size&&(c=r.stashes.values().next().value)&&c.ref!==s?.ref&&c.message?.includes(e)&&(w=!0)}this._recompose?.enabled&&this._recompose.branchName?await m.git.refs.updateReference(`refs/heads/${this._recompose.branchName}`,p[p.length-1]):await f.ops?.reset(p[p.length-1],{mode:"hard"}),c&&w&&await f.stash?.applyStash(c.stashName,{deleteAfter:!0}),this._context.commits.finalCount=p.length,this.sendTelemetryEvent("composer/action/finishAndCommit"),await this.host.notify(W,void 0),i.commands.executeCommand("workbench.action.closeActiveEditor")}catch(t){this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e=t instanceof Error?t.message:"unknown error";this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(W,void 0),i.window.showErrorMessage(`Failed to commit changes: ${e}`)}}onAnyConfigurationChanged(e){if(d.H.changed(e,"ai.enabled")){let e=d.H.get("ai.enabled",void 0,!0);this._context.ai.enabled.config=e,this.host.notify(ee,{config:e})}}onContextChanged(e){if("gitlens:gk:organization:ai:enabled"===e){let e=(0,l.SD)("gitlens:gk:organization:ai:enabled",!0);this._context.ai.enabled.org=e,this.host.notify(ee,{org:e})}}onAIModelChanged(e){this.updateAiModel()}getAiEnabled(){return{org:(0,l.SD)("gitlens:gk:organization:ai:enabled",!0),config:d.H.get("ai.enabled",void 0,!0)}}sendTelemetryEvent(e,t){this.container.telemetry.enabled&&this.container.telemetry.sendEvent(e,{...this.getTelemetryContext(),...t})}_panelWasVisible;_isMaximized=!1;async maximize(){if(this._isMaximized)this._panelWasVisible&&await (0,h.S4)("workbench.action.togglePanel"),this._isMaximized=!1,this._panelWasVisible=void 0;else{try{await (0,h.S4)("workbench.action.focusPanel"),this._panelWasVisible=!0,await (0,h.S4)("workbench.action.togglePanel")}catch{this._panelWasVisible=!1}this._isMaximized=!0}}}}};